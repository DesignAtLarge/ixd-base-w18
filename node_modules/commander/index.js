<<<<<<< HEAD
/*!
 * commander
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
=======
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Module dependencies.
 */

<<<<<<< HEAD
var EventEmitter = require('events').EventEmitter
  , spawn = require('child_process').spawn
  , keypress = require('keypress')
  , fs = require('fs')
  , exists = fs.existsSync
  , path = require('path')
  , tty = require('tty')
  , dirname = path.dirname
  , basename = path.basename;
=======
var EventEmitter = require('events').EventEmitter;
var spawn = require('child_process').spawn;
var path = require('path');
var dirname = path.dirname;
var basename = path.basename;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Expose the root command.
 */

<<<<<<< HEAD
exports = module.exports = new Command;
=======
exports = module.exports = new Command();
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Expose `Command`.
 */

exports.Command = Command;

/**
 * Expose `Option`.
 */

exports.Option = Option;

/**
 * Initialize a new `Option` with the given `flags` and `description`.
 *
 * @param {String} flags
 * @param {String} description
 * @api public
 */

function Option(flags, description) {
  this.flags = flags;
  this.required = ~flags.indexOf('<');
  this.optional = ~flags.indexOf('[');
  this.bool = !~flags.indexOf('-no-');
  flags = flags.split(/[ ,|]+/);
  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || '';
}

/**
 * Return option name.
 *
 * @return {String}
 * @api private
 */

<<<<<<< HEAD
Option.prototype.name = function(){
=======
Option.prototype.name = function() {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  return this.long
    .replace('--', '')
    .replace('no-', '');
};

/**
 * Check if `arg` matches the short or long flag.
 *
 * @param {String} arg
 * @return {Boolean}
 * @api private
 */

<<<<<<< HEAD
Option.prototype.is = function(arg){
  return arg == this.short
    || arg == this.long;
=======
Option.prototype.is = function(arg) {
  return arg == this.short || arg == this.long;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
};

/**
 * Initialize a new `Command`.
 *
 * @param {String} name
 * @api public
 */

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = [];
<<<<<<< HEAD
=======
  this._allowUnknownOption = false;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  this._args = [];
  this._name = name;
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

Command.prototype.__proto__ = EventEmitter.prototype;

/**
 * Add command `name`.
 *
 * The `.action()` callback is invoked when the
 * command `name` is specified via __ARGV__,
 * and the remaining arguments are applied to the
 * function for access.
 *
 * When the `name` is "*" an un-matched command
 * will be passed as the first arg, followed by
 * the rest of __ARGV__ remaining.
 *
 * Examples:
 *
 *      program
 *        .version('0.0.1')
 *        .option('-C, --chdir <path>', 'change the working directory')
 *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
 *        .option('-T, --no-tests', 'ignore test hook')
<<<<<<< HEAD
 *     
 *      program
 *        .command('setup')
 *        .description('run remote setup commands')
 *        .action(function(){
 *          console.log('setup');
 *        });
 *     
 *      program
 *        .command('exec <cmd>')
 *        .description('run the given remote command')
 *        .action(function(cmd){
 *          console.log('exec "%s"', cmd);
 *        });
 *     
 *      program
 *        .command('*')
 *        .description('deploy the given env')
 *        .action(function(env){
 *          console.log('deploying "%s"', env);
 *        });
 *     
 *      program.parse(process.argv);
  *
 * @param {String} name
 * @param {String} [desc]
=======
 *
 *      program
 *        .command('setup')
 *        .description('run remote setup commands')
 *        .action(function() {
 *          console.log('setup');
 *        });
 *
 *      program
 *        .command('exec <cmd>')
 *        .description('run the given remote command')
 *        .action(function(cmd) {
 *          console.log('exec "%s"', cmd);
 *        });
 *
 *      program
 *        .command('teardown <dir> [otherDirs...]')
 *        .description('run teardown commands')
 *        .action(function(dir, otherDirs) {
 *          console.log('dir "%s"', dir);
 *          if (otherDirs) {
 *            otherDirs.forEach(function (oDir) {
 *              console.log('dir "%s"', oDir);
 *            });
 *          }
 *        });
 *
 *      program
 *        .command('*')
 *        .description('deploy the given env')
 *        .action(function(env) {
 *          console.log('deploying "%s"', env);
 *        });
 *
 *      program.parse(process.argv);
  *
 * @param {String} name
 * @param {String} [desc] for git-style sub-commands
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * @return {Command} the new command
 * @api public
 */

<<<<<<< HEAD
Command.prototype.command = function(name, desc){
  var args = name.split(/ +/);
  var cmd = new Command(args.shift());
  if (desc) cmd.description(desc);
  if (desc) this.executables = true;
  if (desc) this._execs[cmd._name] = true;
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;
=======
Command.prototype.command = function(name, desc) {
  var args = name.split(/ +/);
  var cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs[cmd._name] = true;
  }

  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  if (desc) return this;
  return cmd;
};

/**
 * Add an implicit `help [cmd]` subcommand
 * which invokes `--help` for the given command.
 *
 * @api private
 */

Command.prototype.addImplicitHelpCommand = function() {
  this.command('help [cmd]', 'display help for [cmd]');
};

/**
 * Parse expected `args`.
 *
 * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api public
 */

<<<<<<< HEAD
Command.prototype.parseExpectedArgs = function(args){
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg){
    switch (arg[0]) {
      case '<':
        self._args.push({ required: true, name: arg.slice(1, -1) });
        break;
      case '[':
        self._args.push({ required: false, name: arg.slice(1, -1) });
        break;
    }
=======
Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = {
      required: false,
      name: '',
      variadic: false
    };

    switch (arg[0]) {
      case '<':
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case '[':
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    if (argDetails.name) {
      self._args.push(argDetails);
    }
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  });
  return this;
};

/**
 * Register callback `fn` for the command.
 *
 * Examples:
 *
 *      program
 *        .command('help')
 *        .description('display verbose help')
<<<<<<< HEAD
 *        .action(function(){
=======
 *        .action(function() {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *           // output help here
 *        });
 *
 * @param {Function} fn
 * @return {Command} for chaining
 * @api public
 */

<<<<<<< HEAD
Command.prototype.action = function(fn){
  var self = this;
  this.parent.on(this._name, function(args, unknown){    
    // Parse any so-far unknown options
    unknown = unknown || [];
    var parsed = self.parseOptions(unknown);
    
    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);
    
    // If there are still any unknown options, then we simply 
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {      
      self.unknownOption(parsed.unknown[0]);
    }
    
    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);
    
    self._args.forEach(function(arg, i){
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      }
    });
    
=======
Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }
<<<<<<< HEAD
    
    fn.apply(this, args);
  });
=======

    fn.apply(self, args);
  };
  this.parent.on(this._name, listener);
  if (this._alias) this.parent.on(this._alias, listener);
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  return this;
};

/**
 * Define option with `flags`, `description` and optional
<<<<<<< HEAD
 * coercion `fn`. 
=======
 * coercion `fn`.
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 *
 *    "-p, --pepper"
 *    "-p|--pepper"
 *    "-p --pepper"
 *
 * Examples:
 *
 *     // simple boolean defaulting to false
 *     program.option('-p, --pepper', 'add pepper');
 *
 *     --pepper
 *     program.pepper
 *     // => Boolean
 *
<<<<<<< HEAD
 *     // simple boolean defaulting to false
=======
 *     // simple boolean defaulting to true
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *     program.option('-C, --no-cheese', 'remove cheese');
 *
 *     program.cheese
 *     // => true
 *
 *     --no-cheese
 *     program.cheese
<<<<<<< HEAD
 *     // => true
=======
 *     // => false
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *
 *     // required argument
 *     program.option('-C, --chdir <path>', 'change the working directory');
 *
 *     --chdir /tmp
 *     program.chdir
 *     // => "/tmp"
 *
 *     // optional argument
 *     program.option('-c, --cheese [type]', 'add cheese [marble]');
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|Mixed} fn or default
 * @param {Mixed} defaultValue
 * @return {Command} for chaining
 * @api public
 */

<<<<<<< HEAD
Command.prototype.option = function(flags, description, fn, defaultValue){
=======
Command.prototype.option = function(flags, description, fn, defaultValue) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  var self = this
    , option = new Option(flags, description)
    , oname = option.name()
    , name = camelcase(oname);

  // default as 3rd arg
<<<<<<< HEAD
  if ('function' != typeof fn) defaultValue = fn, fn = null;
=======
  if (typeof fn != 'function') {
    defaultValue = fn;
    fn = null;
  }
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  // preassign default value only for --no-*, [optional], or <required>
  if (false == option.bool || option.optional || option.required) {
    // when --no-* we make sure default is true
    if (false == option.bool) defaultValue = true;
    // preassign only if we have a default
    if (undefined !== defaultValue) self[name] = defaultValue;
  }

  // register the option
  this.options.push(option);

  // when it's passed assign the value
  // and conditionally invoke the callback
<<<<<<< HEAD
  this.on(oname, function(val){
    // coercion
    if (null != val && fn) val = fn(val);
=======
  this.on(oname, function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  });

  return this;
};

/**
<<<<<<< HEAD
=======
 * Allow unknown options on the command line.
 *
 * @param {Boolean} arg if `true` or omitted, no error will be thrown
 * for unknown options.
 * @api public
 */
Command.prototype.allowUnknownOption = function(arg) {
    this._allowUnknownOption = arguments.length === 0 || arg;
    return this;
};

/**
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * Parse `argv`, settings options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

<<<<<<< HEAD
Command.prototype.parse = function(argv){
=======
Command.prototype.parse = function(argv) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  // implicit help
  if (this.executables) this.addImplicitHelpCommand();

  // store raw args
  this.rawArgs = argv;

  // guess name
<<<<<<< HEAD
  this._name = this._name || basename(argv[1]);
=======
  this._name = this._name || basename(argv[1], '.js');
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  // process argv
  var parsed = this.parseOptions(this.normalize(argv.slice(2)));
  var args = this.args = parsed.args;
<<<<<<< HEAD
 
=======

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  var result = this.parseArgs(this.args, parsed.unknown);

  // executable sub-commands
  var name = result.args[0];
<<<<<<< HEAD
  if (this._execs[name]) return this.executeSubCommand(argv, args, parsed.unknown);
=======
  if (this._execs[name] && typeof this._execs[name] != "function") {
    return this.executeSubCommand(argv, args, parsed.unknown);
  }
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  return result;
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown) {
  args = args.concat(unknown);

  if (!args.length) this.help();
  if ('help' == args[0] && 1 == args.length) this.help();

  // <cmd> --help
  if ('help' == args[0]) {
    args[0] = args[1];
    args[1] = '--help';
  }

  // executable
  var dir = dirname(argv[1]);
<<<<<<< HEAD
  var bin = basename(argv[1]) + '-' + args[0];
=======
  var bin = basename(argv[1], '.js') + '-' + args[0];
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  // check for ./<bin> first
  var local = path.join(dir, bin);

  // run it
  args = args.slice(1);
<<<<<<< HEAD
  var proc = spawn(local, args, { stdio: 'inherit', customFds: [0, 1, 2] });
  proc.on('error', function(err){
=======
  args.unshift(local);
  var proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
  proc.on('error', function(err) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    if (err.code == "ENOENT") {
      console.error('\n  %s(1) does not exist, try --help\n', bin);
    } else if (err.code == "EACCES") {
      console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
    }
  });

  this.runningCommand = proc;
};

/**
 * Normalize `args`, splitting joined short flags. For example
 * the arg "-abc" is equivalent to "-a -b -c".
 * This also normalizes equal sign and splits "--abc=def" into "--abc def".
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.normalize = function(args){
  var ret = []
    , arg
=======
Command.prototype.normalize = function(args) {
  var ret = []
    , arg
    , lastOpt
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    , index;

  for (var i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
<<<<<<< HEAD
    if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
      arg.slice(1).split('').forEach(function(c){
=======
    if (i > 0) {
      lastOpt = this.optionFor(args[i-1]);
    }

    if (arg === '--') {
      // Honor option terminator
      ret = ret.concat(args.slice(i));
      break;
    } else if (lastOpt && lastOpt.required) {
      ret.push(arg);
    } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
      arg.slice(1).split('').forEach(function(c) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
        ret.push('-' + c);
      });
    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
      ret.push(arg.slice(0, index), arg.slice(index + 1));
    } else {
      ret.push(arg);
    }
  }

  return ret;
};

/**
 * Parse command `args`.
 *
 * When listener(s) are available those
 * callbacks are invoked, otherwise the "*"
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

<<<<<<< HEAD
Command.prototype.parseArgs = function(args, unknown){
  var cmds = this.commands
    , len = cmds.length
    , name;
=======
Command.prototype.parseArgs = function(args, unknown) {
  var name;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  if (args.length) {
    name = args[0];
    if (this.listeners(name).length) {
      this.emit(args.shift(), args, unknown);
    } else {
      this.emit('*', args);
    }
  } else {
    outputHelpIfNecessary(this, unknown);
<<<<<<< HEAD
    
    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length > 0) {      
=======

    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length > 0) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
      this.unknownOption(unknown[0]);
    }
  }

  return this;
};

/**
 * Return an option matching `arg` if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.optionFor = function(arg){
=======
Command.prototype.optionFor = function(arg) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  for (var i = 0, len = this.options.length; i < len; ++i) {
    if (this.options[i].is(arg)) {
      return this.options[i];
    }
  }
};

/**
 * Parse options from `argv` returning `argv`
 * void of these options.
 *
 * @param {Array} argv
 * @return {Array}
 * @api public
 */

<<<<<<< HEAD
Command.prototype.parseOptions = function(argv){
=======
Command.prototype.parseOptions = function(argv) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  var args = []
    , len = argv.length
    , literal
    , option
    , arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i < len; ++i) {
    arg = argv[i];

    // literal args after --
    if ('--' == arg) {
      literal = true;
      continue;
    }

    if (literal) {
      args.push(arg);
      continue;
    }

    // find matching Option
    option = this.optionFor(arg);

    // option is defined
    if (option) {
      // requires arg
      if (option.required) {
        arg = argv[++i];
        if (null == arg) return this.optionMissingArgument(option);
<<<<<<< HEAD
        if ('-' == arg[0] && '-' != arg) return this.optionMissingArgument(option, arg);
=======
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
        this.emit(option.name(), arg);
      // optional arg
      } else if (option.optional) {
        arg = argv[i+1];
        if (null == arg || ('-' == arg[0] && '-' != arg)) {
          arg = null;
        } else {
          ++i;
        }
        this.emit(option.name(), arg);
      // bool
      } else {
        this.emit(option.name());
      }
      continue;
    }
<<<<<<< HEAD
    
    // looks like an option
    if (arg.length > 1 && '-' == arg[0]) {
      unknownOptions.push(arg);
      
=======

    // looks like an option
    if (arg.length > 1 && '-' == arg[0]) {
      unknownOptions.push(arg);

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn't, then it'll simply be ignored
      if (argv[i+1] && '-' != argv[i+1][0]) {
        unknownOptions.push(argv[++i]);
      }
      continue;
    }
<<<<<<< HEAD
    
    // arg
    args.push(arg);
  }
  
=======

    // arg
    args.push(arg);
  }

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  return { args: args, unknown: unknownOptions };
};

/**
<<<<<<< HEAD
=======
 * Return an object containing options as key-value pairs
 *
 * @return {Object}
 * @api public
 */
Command.prototype.opts = function() {
  var result = {}
    , len = this.options.length;

  for (var i = 0 ; i < len; i++) {
    var key = this.options[i].name();
    result[key] = key === 'version' ? this._version : this[key];
  }
  return result;
};

/**
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * Argument `name` is missing.
 *
 * @param {String} name
 * @api private
 */

<<<<<<< HEAD
Command.prototype.missingArgument = function(name){
=======
Command.prototype.missingArgument = function(name) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  console.error();
  console.error("  error: missing required argument `%s'", name);
  console.error();
  process.exit(1);
};

/**
 * `Option` is missing an argument, but received `flag` or nothing.
 *
 * @param {String} option
 * @param {String} flag
 * @api private
 */

<<<<<<< HEAD
Command.prototype.optionMissingArgument = function(option, flag){
=======
Command.prototype.optionMissingArgument = function(option, flag) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  console.error();
  if (flag) {
    console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
  } else {
    console.error("  error: option `%s' argument missing", option.flags);
  }
  console.error();
  process.exit(1);
};

/**
 * Unknown option `flag`.
 *
 * @param {String} flag
 * @api private
 */

<<<<<<< HEAD
Command.prototype.unknownOption = function(flag){
=======
Command.prototype.unknownOption = function(flag) {
  if(this._allowUnknownOption) return;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  console.error();
  console.error("  error: unknown option `%s'", flag);
  console.error();
  process.exit(1);
};

<<<<<<< HEAD
=======
/**
 * Variadic argument with `name` is not the last argument as required.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.variadicArgNotLast = function(name) {
  console.error();
  console.error("  error: variadic arguments must be last `%s'", name);
  console.error();
  process.exit(1);
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Set the program version to `str`.
 *
 * This method auto-registers the "-V, --version" flag
 * which will print the version number when passed.
 *
 * @param {String} str
 * @param {String} flags
 * @return {Command} for chaining
 * @api public
 */

<<<<<<< HEAD
Command.prototype.version = function(str, flags){
=======
Command.prototype.version = function(str, flags) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  if (0 == arguments.length) return this._version;
  this._version = str;
  flags = flags || '-V, --version';
  this.option(flags, 'output the version number');
<<<<<<< HEAD
  this.on('version', function(){
    console.log(str);
=======
  this.on('version', function() {
    process.stdout.write(str + '\n');
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    process.exit(0);
  });
  return this;
};

/**
<<<<<<< HEAD
 * Set the description `str`.
=======
 * Set the description to `str`.
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

<<<<<<< HEAD
Command.prototype.description = function(str){
=======
Command.prototype.description = function(str) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  if (0 == arguments.length) return this._description;
  this._description = str;
  return this;
};

/**
<<<<<<< HEAD
=======
 * Set an alias for the command
 *
 * @param {String} alias
 * @return {String|Command}
 * @api public
 */

Command.prototype.alias = function(alias) {
  if (0 == arguments.length) return this._alias;
  this._alias = alias;
  return this;
};

/**
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * Set / get the command usage `str`.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

<<<<<<< HEAD
Command.prototype.usage = function(str){
  var args = this._args.map(function(arg){
    return arg.required
      ? '<' + arg.name + '>'
      : '[' + arg.name + ']';
  });

  var usage = '[options'
    + (this.commands.length ? '] [command' : '')
    + ']'
    + (this._args.length ? ' ' + args : '');
=======
Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = '[options]'
    + (this.commands.length ? ' [command]' : '')
    + (this._args.length ? ' ' + args.join(' ') : '');
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  if (0 == arguments.length) return this._usage || usage;
  this._usage = str;

  return this;
};

/**
<<<<<<< HEAD
=======
 * Get the name of the command
 *
 * @param {String} name
 * @return {String|Command}
 * @api public
 */

Command.prototype.name = function(name) {
  return this._name;
};

/**
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.largestOptionLength = function(){
  return this.options.reduce(function(max, option){
=======
Command.prototype.largestOptionLength = function() {
  return this.options.reduce(function(max, option) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    return Math.max(max, option.flags.length);
  }, 0);
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.optionHelp = function(){
  var width = this.largestOptionLength();
  
  // Prepend the help information
  return [pad('-h, --help', width) + '  ' + 'output usage information']
    .concat(this.options.map(function(option){
      return pad(option.flags, width)
        + '  ' + option.description;
=======
Command.prototype.optionHelp = function() {
  var width = this.largestOptionLength();

  // Prepend the help information
  return [pad('-h, --help', width) + '  ' + 'output usage information']
    .concat(this.options.map(function(option) {
      return pad(option.flags, width) + '  ' + option.description;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
      }))
    .join('\n');
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.commandHelp = function(){
  if (!this.commands.length) return '';
=======
Command.prototype.commandHelp = function() {
  if (!this.commands.length) return '';

  var commands = this.commands.map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(' ');

    return [
      cmd._name
        + (cmd._alias
          ? '|' + cmd._alias
          : '')
        + (cmd.options.length
          ? ' [options]'
          : '')
        + ' ' + args
    , cmd.description()
    ];
  });

  var width = commands.reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  return [
      ''
    , '  Commands:'
    , ''
<<<<<<< HEAD
    , this.commands.map(function(cmd){
      var args = cmd._args.map(function(arg){
        return arg.required
          ? '<' + arg.name + '>'
          : '[' + arg.name + ']';
      }).join(' ');

      return pad(cmd._name
        + (cmd.options.length 
          ? ' [options]'
          : '') + ' ' + args, 22)
        + (cmd.description()
          ? ' ' + cmd.description()
          : '');
=======
    , commands.map(function(cmd) {
      return pad(cmd[0], width) + '  ' + cmd[1];
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    }).join('\n').replace(/^/gm, '    ')
    , ''
  ].join('\n');
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

<<<<<<< HEAD
Command.prototype.helpInformation = function(){
  return [
      ''
    , '  Usage: ' + this._name + ' ' + this.usage()
    , '' + this.commandHelp()
    , '  Options:'
    , ''
    , '' + this.optionHelp().replace(/^/gm, '    ')
    , ''
    , ''
  ].join('\n');
};

/**
 * Prompt for a `Number`.
 *
 * @param {String} str
 * @param {Function} fn
 * @api private
 */

Command.prototype.promptForNumber = function(str, fn){
  var self = this;
  this.promptSingleLine(str, function parseNumber(val){
    val = Number(val);
    if (isNaN(val)) return self.promptSingleLine(str + '(must be a number) ', parseNumber);
    fn(val);
  });
};

/**
 * Prompt for a `Date`.
 *
 * @param {String} str
 * @param {Function} fn
 * @api private
 */

Command.prototype.promptForDate = function(str, fn){
  var self = this;
  this.promptSingleLine(str, function parseDate(val){
    val = new Date(val);
    if (isNaN(val.getTime())) return self.promptSingleLine(str + '(must be a date) ', parseDate);
    fn(val);
  });
};


/**
 * Prompt for a `Regular Expression`.
 *
 * @param {String} str
 * @param {Object} pattern regular expression object to test
 * @param {Function} fn
 * @api private
 */

Command.prototype.promptForRegexp = function(str, pattern, fn){
  var self = this;
  this.promptSingleLine(str, function parseRegexp(val){
    if(!pattern.test(val)) return self.promptSingleLine(str + '(regular expression mismatch) ', parseRegexp);
    fn(val);
  });
};


/**
 * Single-line prompt.
 *
 * @param {String} str
 * @param {Function} fn
 * @api private
 */

Command.prototype.promptSingleLine = function(str, fn){
  // determine if the 2nd argument is a regular expression
  if (arguments[1].global !== undefined && arguments[1].multiline !== undefined) {
    return this.promptForRegexp(str, arguments[1], arguments[2]);
  } else if ('function' == typeof arguments[2]) {
    return this['promptFor' + (fn.name || fn)](str, arguments[2]);
  }

  process.stdout.write(str);
  process.stdin.setEncoding('utf8');
  process.stdin.once('data', function(val){
    fn(val.trim());
  }).resume();
};

/**
 * Multi-line prompt.
 *
 * @param {String} str
 * @param {Function} fn
 * @api private
 */

Command.prototype.promptMultiLine = function(str, fn){
  var buf = [];
  console.log(str);
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function(val){
    if ('\n' == val || '\r\n' == val) {
      process.stdin.removeAllListeners('data');
      fn(buf.join('\n'));
    } else {
      buf.push(val.trimRight());
    }
  }).resume();
};

/**
 * Prompt `str` and callback `fn(val)`
 *
 * Commander supports single-line and multi-line prompts.
 * To issue a single-line prompt simply add white-space
 * to the end of `str`, something like "name: ", whereas
 * for a multi-line prompt omit this "description:".
 *
 *
 * Examples:
 *
 *     program.prompt('Username: ', function(name){
 *       console.log('hi %s', name);
 *     });
 *     
 *     program.prompt('Description:', function(desc){
 *       console.log('description was "%s"', desc.trim());
 *     });
 *
 * @param {String|Object} str
 * @param {Function} fn
 * @api public
 */

Command.prototype.prompt = function(str, fn){
  var self = this;
  if ('string' == typeof str) {
    if (/ $/.test(str)) return this.promptSingleLine.apply(this, arguments);
    this.promptMultiLine(str, fn);
  } else {
    var keys = Object.keys(str)
      , obj = {};

    function next() {
      var key = keys.shift()
        , label = str[key];

      if (!key) return fn(obj);
      self.prompt(label, function(val){
        obj[key] = val;
        next();
      });
    }

    next();
  }
};

/**
 * Prompt for password with `str`, `mask` char and callback `fn(val)`.
 *
 * The mask string defaults to '', aka no output is
 * written while typing, you may want to use "*" etc.
 *
 * Examples:
 *
 *     program.password('Password: ', function(pass){
 *       console.log('got "%s"', pass);
 *       process.stdin.destroy();
 *     });
 *
 *     program.password('Password: ', '*', function(pass){
 *       console.log('got "%s"', pass);
 *       process.stdin.destroy();
 *     });
 *
 * @param {String} str
 * @param {String} mask
 * @param {Function} fn
 * @api public
 */

Command.prototype.password = function(str, mask, fn){
  var self = this
    , buf = '';

  // default mask
  if ('function' == typeof mask) {
    fn = mask;
    mask = '';
  }

  keypress(process.stdin);

  function setRawMode(mode) {
    if (process.stdin.setRawMode) {
      process.stdin.setRawMode(mode);
    } else {
      tty.setRawMode(mode);
    }
  };
  setRawMode(true);
  process.stdout.write(str);

  // keypress
  process.stdin.on('keypress', function(c, key){
    if (key && 'enter' == key.name) {
      console.log();
      process.stdin.pause();
      process.stdin.removeAllListeners('keypress');
      setRawMode(false);
      if (!buf.trim().length) return self.password(str, mask, fn);
      fn(buf);
      return;
    }

    if (key && key.ctrl && 'c' == key.name) {
      console.log('%s', buf);
      process.exit();
    }

    process.stdout.write(mask);
    buf += c;
  }).resume();
};

/**
 * Confirmation prompt with `str` and callback `fn(bool)`
 *
 * Examples:
 *
 *      program.confirm('continue? ', function(ok){
 *        console.log(' got %j', ok);
 *        process.stdin.destroy();
 *      });
 *
 * @param {String} str
 * @param {Function} fn
 * @api public
 */


Command.prototype.confirm = function(str, fn, verbose){
  var self = this;
  this.prompt(str, function(ok){
    if (!ok.trim()) {
      if (!verbose) str += '(yes or no) ';
      return self.confirm(str, fn, true);
    }
    fn(parseBool(ok));
  });
};

/**
 * Choice prompt with `list` of items and callback `fn(index, item)`
 *
 * Examples:
 *
 *      var list = ['tobi', 'loki', 'jane', 'manny', 'luna'];
 *      
 *      console.log('Choose the coolest pet:');
 *      program.choose(list, function(i){
 *        console.log('you chose %d "%s"', i, list[i]);
 *        process.stdin.destroy();
 *      });
 *
 * @param {Array} list
 * @param {Number|Function} index or fn
 * @param {Function} fn
 * @api public
 */

Command.prototype.choose = function(list, index, fn){
  var self = this
    , hasDefault = 'number' == typeof index;

  if (!hasDefault) {
    fn = index;
    index = null;
  }

  list.forEach(function(item, i){
    if (hasDefault && i == index) {
      console.log('* %d) %s', i + 1, item);
    } else {
      console.log('  %d) %s', i + 1, item);
    }
  });

  function again() {
    self.prompt('  : ', function(val){
      val = parseInt(val, 10) - 1;
      if (hasDefault && isNaN(val)) val = index;

      if (null == list[val]) {
        again();
      } else {
        fn(val, list[val]);
      }
    });
  }

  again();
};


=======
Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [
      '  ' + this._description
      , ''
    ];
  }

  var cmdName = this._name;
  if(this._alias) {
    cmdName = cmdName + '|' + this._alias;
  }
  var usage = [
    ''
    ,'  Usage: ' + cmdName + ' ' + this.usage()
    , ''
  ];

  var cmds = [];
  var commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = [
    '  Options:'
    , ''
    , '' + this.optionHelp().replace(/^/gm, '    ')
    , ''
    , ''
  ];

  return usage
    .concat(cmds)
    .concat(desc)
    .concat(options)
    .join('\n');
};

>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
/**
 * Output help information for this command
 *
 * @api public
 */

<<<<<<< HEAD
Command.prototype.outputHelp = function(){
=======
Command.prototype.outputHelp = function() {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  process.stdout.write(this.helpInformation());
  this.emit('--help');
};

/**
 * Output help information and exit.
 *
 * @api public
 */

<<<<<<< HEAD
Command.prototype.help = function(){
=======
Command.prototype.help = function() {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  this.outputHelp();
  process.exit();
};

/**
 * Camel-case the given `flag`
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag) {
<<<<<<< HEAD
  return flag.split('-').reduce(function(str, word){
=======
  return flag.split('-').reduce(function(str, word) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
<<<<<<< HEAD
 * Parse a boolean `str`.
 *
 * @param {String} str
 * @return {Boolean}
 * @api private
 */

function parseBool(str) {
  return /^y|yes|ok|true$/i.test(str);
}

/**
=======
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 * Pad `str` to `width`.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}

/**
 * Output help information if necessary
 *
 * @param {Command} command to output help for
 * @param {Array} array of options to search for -h or --help
 * @api private
 */

function outputHelpIfNecessary(cmd, options) {
  options = options || [];
  for (var i = 0; i < options.length; i++) {
    if (options[i] == '--help' || options[i] == '-h') {
      cmd.outputHelp();
      process.exit(0);
    }
  }
}
<<<<<<< HEAD
=======

/**
 * Takes an argument an returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {String}
 * @api private
 */

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']'
}
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
