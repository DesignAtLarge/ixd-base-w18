'use strict';

/*!
 * Module dependencies.
 */

<<<<<<< HEAD
var mongodb = require('mongodb')
  , ReadPref = mongodb.ReadPreference
  , ObjectId = mongodb.ObjectID
  , RegExpClone = require('regexp-clone')

/**
 * Object clone with Mongoose natives support.
 *
 * Creates a minimal data Object.
 * It does not clone empty Arrays, empty Objects, and undefined values.
 * This makes the data payload sent to MongoDB as minimal as possible.
=======
var Buffer = require('safe-buffer').Buffer;
var RegExpClone = require('regexp-clone');

var specialProperties = ['__proto__', 'constructor', 'prototype'];

/**
 * Clones objects
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @return {Object} the cloned object
 * @api private
 */

<<<<<<< HEAD
exports.clone = function clone (obj, options) {
=======
var clone = exports.clone = function clone(obj, options) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  if (obj === undefined || obj === null)
    return obj;

  if (Array.isArray(obj))
    return exports.cloneArray(obj, options);

<<<<<<< HEAD
  if ('Object' === obj.constructor.name)
    return exports.cloneObject(obj, options);

  if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
    return new obj.constructor(+obj);

  if ('RegExp' === obj.constructor.name) {
    return RegExpClone(obj);
  }

  if (obj instanceof ObjectId)
    return new ObjectId(obj.id);
=======
  if (obj.constructor) {
    if (/ObjectI[dD]$/.test(obj.constructor.name)) {
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.id);
    }

    if (obj.constructor.name === 'ReadPreference') {
      return new obj.constructor(obj.mode, clone(obj.tags, options));
    }

    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.value(true), obj.sub_type);
    }

    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
      return new obj.constructor(+obj);

    if ('RegExp' === obj.constructor.name)
      return RegExpClone(obj);

    if ('Buffer' === obj.constructor.name)
      return exports.cloneBuffer(obj);
  }

  if (isObject(obj))
    return exports.cloneObject(obj, options);
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  if (obj.valueOf)
    return obj.valueOf();
};
<<<<<<< HEAD
var clone = exports.clone;
=======
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/*!
 * ignore
 */

<<<<<<< HEAD
var cloneObject = exports.cloneObject = function cloneObject (obj, options) {
  var retainKeyOrder = options && options.retainKeyOrder
    , minimize = options && options.minimize
    , ret = {}
    , hasKeys
    , keys
    , val
    , k
    , i

  if (retainKeyOrder) {
    for (k in obj) {
      val = clone(obj[k], options);

      if (!minimize || ('undefined' !== typeof val)) {
        hasKeys || (hasKeys = true);
        ret[k] = val;
      }
    }
  } else {
    // faster

    keys = Object.keys(obj);
    i = keys.length;

    while (i--) {
      k = keys[i];
      val = clone(obj[k], options);

      if (!minimize || ('undefined' !== typeof val)) {
        if (!hasKeys) hasKeys = true;
        ret[k] = val;
      }
=======
exports.cloneObject = function cloneObject(obj, options) {
  var minimize = options && options.minimize;
  var ret = {};
  var hasKeys;
  var val;
  var k;

  for (k in obj) {
    // Not technically prototype pollution because this wouldn't merge properties
    // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.
    if (specialProperties.indexOf(k) !== -1) {
      continue;
    }

    val = clone(obj[k], options);

    if (!minimize || ('undefined' !== typeof val)) {
      hasKeys || (hasKeys = true);
      ret[k] = val;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    }
  }

  return minimize
    ? hasKeys && ret
    : ret;
};

<<<<<<< HEAD
var cloneArray = exports.cloneArray = function cloneArray (arr, options) {
=======
exports.cloneArray = function cloneArray(arr, options) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++)
    ret.push(clone(arr[i], options));
  return ret;
};

/**
 * process.nextTick helper.
 *
 * Wraps the given `callback` in a try/catch. If an error is
 * caught it will be thrown on nextTick.
 *
 * node-mongodb-native had a habit of state corruption when
 * an error was immediately thrown from within a collection
 * method (find, update, etc) callback.
 *
 * @param {Function} [callback]
 * @api private
 */

<<<<<<< HEAD
var tick = exports.tick = function tick (callback) {
  if ('function' !== typeof callback) return;
  return function () {
=======
exports.tick = function tick(callback) {
  if ('function' !== typeof callback) return;
  return function() {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    // callbacks should always be fired on the next
    // turn of the event loop. A side benefit is
    // errors thrown from executing the callback
    // will not cause drivers state to be corrupted
    // which has historically been a problem.
    var args = arguments;
<<<<<<< HEAD
    soon(function(){
      callback.apply(this, args);
    });
  }
}
=======
    soon(function() {
      callback.apply(this, args);
    });
  };
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */

<<<<<<< HEAD
var merge = exports.merge = function merge (to, from) {
  var keys = Object.keys(from)
    , i = keys.length
    , key

  while (i--) {
    key = keys[i];
=======
exports.merge = function merge(to, from) {
  var keys = Object.keys(from),
      i = keys.length,
      key;

  while (i--) {
    key = keys[i];
    if (specialProperties.indexOf(key) !== -1) {
      continue;
    }
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    if ('undefined' === typeof to[key]) {
      to[key] = from[key];
    } else {
      if (exports.isObject(from[key])) {
        merge(to[key], from[key]);
      } else {
        to[key] = from[key];
      }
    }
  }
<<<<<<< HEAD
}
=======
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Same as merge but clones the assigned values.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */

<<<<<<< HEAD
var mergeClone = exports.mergeClone = function mergeClone (to, from) {
  var keys = Object.keys(from)
    , i = keys.length
    , key
=======
exports.mergeClone = function mergeClone(to, from) {
  var keys = Object.keys(from),
      i = keys.length,
      key;
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

  while (i--) {
    key = keys[i];
    if ('undefined' === typeof to[key]) {
<<<<<<< HEAD
      // make sure to retain key order here because of a bug handling the $each
      // operator in mongodb 2.4.4
      to[key] = clone(from[key], { retainKeyOrder : 1});
=======
      to[key] = clone(from[key]);
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
    } else {
      if (exports.isObject(from[key])) {
        mergeClone(to[key], from[key]);
      } else {
<<<<<<< HEAD
        // make sure to retain key order here because of a bug handling the
        // $each operator in mongodb 2.4.4
        to[key] = clone(from[key], { retainKeyOrder : 1});
      }
    }
  }
}
=======
        to[key] = clone(from[key]);
      }
    }
  }
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Read pref helper (mongo 2.2 drivers support this)
 *
 * Allows using aliases instead of full preference names:
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
<<<<<<< HEAD
 * @param {String|Array} pref
 * @param {Array} [tags]
 */

exports.readPref = function readPref (pref, tags) {
  if (Array.isArray(pref)) {
    tags = pref[1];
    pref = pref[0];
  }

=======
 * @param {String} pref
 */

exports.readPref = function readPref(pref) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  switch (pref) {
    case 'p':
      pref = 'primary';
      break;
    case 'pp':
      pref = 'primaryPreferred';
      break;
    case 's':
      pref = 'secondary';
      break;
    case 'sp':
      pref = 'secondaryPreferred';
      break;
    case 'n':
      pref = 'nearest';
      break;
  }

<<<<<<< HEAD
  return new ReadPref(pref, tags);
}
=======
  return pref;
};


/**
 * Read Concern helper (mongo 3.2 drivers support this)
 *
 * Allows using string to specify read concern level:
 *
 *     local          3.2+
 *     available      3.6+
 *     majority       3.2+
 *     linearizable   3.4+
 *     snapshot       4.0+
 *
 * @param {String|Object} concern
 */

exports.readConcern = function readConcern(concern) {
  if ('string' === typeof concern) {
    switch (concern) {
      case 'l':
        concern = 'local';
        break;
      case 'a':
        concern = 'available';
        break;
      case 'm':
        concern = 'majority';
        break;
      case 'lz':
        concern = 'linearizable';
        break;
      case 's':
        concern = 'snapshot';
        break;
    }
    concern = { level: concern };
  }
  return concern;
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Object.prototype.toString.call helper
 */

<<<<<<< HEAD
var toString = Object.prototype.toString;
exports.toString = function (arg) {
  return toString.call(arg);
}
=======
var _toString = Object.prototype.toString;
exports.toString = function(arg) {
  return _toString.call(arg);
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @return {Boolean}
 */

<<<<<<< HEAD
exports.isObject = function (arg) {
  return '[object Object]' == exports.toString(arg);
}
=======
var isObject = exports.isObject = function(arg) {
  return '[object Object]' == exports.toString(arg);
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Determines if `arg` is an array.
 *
 * @param {Object}
 * @return {Boolean}
 * @see nodejs utils
 */

<<<<<<< HEAD
exports.isArray = function (arg) {
  return Array.isArray(arg) ||
    'object' == typeof arg && '[object Array]' == exports.toString(arg);
}
=======
exports.isArray = function(arg) {
  return Array.isArray(arg) ||
    'object' == typeof arg && '[object Array]' == exports.toString(arg);
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Object.keys helper
 */

<<<<<<< HEAD
exports.keys = Object.keys || function (obj) {
=======
exports.keys = Object.keys || function(obj) {
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  var keys = [];
  for (var k in obj) if (obj.hasOwnProperty(k)) {
    keys.push(k);
  }
  return keys;
<<<<<<< HEAD
}
=======
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * Basic Object.create polyfill.
 * Only one argument is supported.
 *
 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 */

exports.create = 'function' == typeof Object.create
  ? Object.create
  : create;

<<<<<<< HEAD
function create (proto) {
  if (arguments.length > 1) {
    throw new Error("Adding properties is not supported")
  }

  function F () {}
=======
function create(proto) {
  if (arguments.length > 1) {
    throw new Error('Adding properties is not supported');
  }

  function F() {}
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
  F.prototype = proto;
  return new F;
}

/**
 * inheritance
 */

<<<<<<< HEAD
exports.inherits = function (ctor, superCtor) {
  ctor.prototype = exports.create(superCtor.prototype);
  ctor.prototype.constructor = ctor;
}
=======
exports.inherits = function(ctor, superCtor) {
  ctor.prototype = exports.create(superCtor.prototype);
  ctor.prototype.constructor = ctor;
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64

/**
 * nextTick helper
 * compat with node 0.10 which behaves differently than previous versions
 */

var soon = exports.soon = 'function' == typeof setImmediate
  ? setImmediate
  : process.nextTick;

/**
<<<<<<< HEAD
 * need to export this for checking issues
 */

exports.mongo = mongodb;
=======
 * Clones the contents of a buffer.
 *
 * @param {Buffer} buff
 * @return {Buffer}
 */

exports.cloneBuffer = function(buff) {
  var dupe = Buffer.alloc(buff.length);
  buff.copy(dupe, 0, 0, buff.length);
  return dupe;
};

/**
 * Check if this object is an arguments object
 *
 * @param {Any} v
 * @return {Boolean}
 */

exports.isArgumentsObject = function(v) {
  return Object.prototype.toString.call(v) === '[object Arguments]';
};
>>>>>>> 2dbc38419e514781ab6a0fba52971ec3257fea64
